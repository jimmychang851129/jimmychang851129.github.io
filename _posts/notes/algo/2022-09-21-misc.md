---
layout: post
title:  "c++ misc"
date:   2021-02-05 21:44:00
categories: Algorithm
tags: Course
---

#### Call by reference

主要是利用reference operator來做的, 為C++特有的operator, 實作細節應該是利用alias 讓兩個變數名稱指向同個記憶體位置

```
int &M = n;
代表Ｍ的位址指向n的位址, 這裡的&是reference operator
這樣Ｍ的值修改也會跟著修改n的值, 所以函式傳遞參數時也是使用reference operator

相對的
int m = &n; 則是address operator
這裡m的值會是n的記憶體位置的整數值
```

reference operator的幾個特性:<br />
1. 再initialize時一定要指到某個變數，不能像pointer一樣init時為NULL
2. init完後指到的位置就不能再變
3. 在for loop or function call時很好用, 能避免大物件的copy

Reference:<br />
[geekforgeek](https://www.geeksforgeeks.org/references-in-c/)<br />


#### function pointer

宣告一個指標指向function的instance

```
void func1(int a, int b)

void *(funcptr)(int,int)  這等於是一個function pointer叫做funcptr 他會指到接收兩個int當參數, 回傳void的function

funcptr = &func1

著名例子就是qsort這種可以定義最後comparison function時, function實作的參數就會用到function pointer

void qsort(void* base, size_t n, size_t size, int (*cmp)(const void*, const void*));
有一個function pointer叫做cmp指到接收兩個參數，回傳int的function
```

另一個常見的usecase就是multithread中的callback function, 在要平行化的function宣告一個function pointer, 這個function pointer接收的function就是在平行化的function做完後執行這個callback function 他可以根據使用者傳入的function執行不同的function

最後一種就是refactor時常用的, 避免過多的if else, 用function pointer更簡潔

加碼: 閱讀複雜的pointer的句子方法

```
void ** (*d) (int &, char*) -> 一個function pointer d, 接收一個reference int, 跟char pointer 回傳一個兩層pointer
```

reference: [閱讀複雜pointer的句子](https://dotblogs.com.tw/brian/2012/10/18/77588)

#### Constructor & Destructor

用於class, struct建立時預先跑的一段function來初始化class, struct(通常是初始化變數值). 基本上struct跟class是一樣的東西, 可以用variable, member function, contructor, destructor，但struct所有member function, variable都是public, 沒有private, 此外他也沒有繼承的功能

```
struct trie{
  struct trie *next[26];
  int val;
  trie() val(0){
    for(int i = 0 ; i <26 ; i++){
      this->next[i] = NULL;
    }
  }
  ~trie(){
    for(int i = 0 ; i < 26 ; i++){
      if(this->next[i] != NULL) delete this->next[i];
    }
  }
}
```

constructor就是一個沒有回傳值的function, function name要是class name或struct name, constructor宣告是可以overload的, 就是可以有複數個constructor, 只要他的paramter不同即可.

Destructor就是在建立這個class/struct的function結束時, 會呼叫destructor來刪除物件, 如果物件本身都是靜態記憶體配置(沒有用到malloc, new) 那其實有沒有destructor通常是沒差, 主要是有動態配置記憶體, function結束,用完時要把它清掉, 不然就memory leak. 如果一個function裡有多個constructor呼叫，那function結束時, destructor呼叫的順序會是反序(stack FILO的方式, 最晚建立的物件會最先被呼叫desctructor)


Class裡的static function是就算class object還沒有建立還是能夠使用的function，但靜態函數不能夠存取class內的非靜態成員資料，一個原因當然是使用static function時不一定有物件建立了

```
class A{
  static int getA(){...};
}

A::getA()  使用class static function時要使用::這個operator來使用
```

Class裡的static variable是所有物件的共用變數而不屬於任一個物件,所以他可以被大家存取，static variable也不能使用this, 因為他不屬於物件的一部分

```
class A{
  static int c;
}
A::c = 4; 可以在不用建立class object時就初始化或修改值
```

#### friend class/method

friend function代表該function雖然宣告在class內，但跟static一樣該function不屬於該class, 外部的class或其他人都可以直接使用該function, 而friend function一個很大用處是雖然他不屬於class, 但他可以存取class object內的所有成員(public, private...都可以)

```
class A{
  int fires;
  friend int getfires(Fires obj){return obj.fires;}
};

class B{
  void print(A &obj){
    cout<< getfires(obj)
  }
}

int main(){
  A f;
  getfires(obj)
}
```

friend class, 如果class A是class B的friend, 則class B可以使用class A的任何成員(public,private...)

```
class A{
  friend class B;
}
class B{}
```

1. friend是單向的, 也就是上述例子class B可以使用class A的任何成員, 但class A不能使用class B的任意成員
2. friend的關係是不可轉移的，例如class A是class B的friend, class B是class C的friend, 但class C不能夠直接存取class A的內容
3. friend關係不能被繼承，如果class A是class B的friend，繼承class B的class不能使用class A的成員


### Virtual Function

Virtual Function是為了實現C++裡的OOP多型的指令。

多型的概念是在於對於有繼承關係的Class, 可以對於某些function, derived class跟base class有不同的實作跟行為。 做法就是在base class把想要多型(根據class有不同實作的function)宣告virtual, 然後再derived class就可以override這些function

使用Virtual Function方法是宣告一個base class pointer, 然後這個pointer會根據指向的derived class種類來run-time link virtual function, 所以pointer指到derived class A，那這個pointer呼叫virtual function時他就會使用到class A的function實做.

Destructor也可以使用virtual function, 這樣在derived class就可以使用自己的destructor然後也會呼叫到base class的desctructor, 不然如果只有base class有destructor, 然後derived class沒有的話，會呼叫到base class的destructor, 那就有可能導致潛在的memory leak問題, 例如derived class自己擁有的variable使用了new指令, 而base class如果沒有這個變數的話，只呼叫base class constructor會造成memory leak, 這些new的變數不會被清掉。

```
class X{
  virtual void run(){
    puts("X");
  }
}

class A:X{
  void run(){
    puts("A");
  }
}

int main(){
  X *ptr;
  A sample;
  ptr = &sample;
  ptr->run()  // output A
}
```

Ｖirtual Function的特色就是這些function是在run-time link到code section而不是compile time link, 因為他是看指到哪個 實作概念上就是對於這些function會在symbol table上一開始先不填上code section, 而是在跑起來時，根據指到的derived class再填入function的位址。而實際上就是class在建立時會有一個欄位叫做vptr,他會指向這個class的vtable, vtable就是紀錄各個virtual function他指向的code section


Reference: [vptr,vtable](https://yosef-gao.github.io/2016/09/27/cpp-vptr-and-vtable/)


### Smart Pointer

C++ pointer一個很常見的問題是memory leak, 常常一不小心new的東西忘了呼叫delete。所以smart pointer就是要避免這種new完忘記delete所發展出的東西，

```
std::unique_ptr<Class A> the_owner = std::make_unique<Class A>();
```

上述語法就能夠用smart pointer指向一個new object, 然後再他的section結束時(例如function return) 就會自動把smart pointer指到的物件清掉

#### New & Delete

C++提供了新的memory allocation的function, 跟C的malloc, free相比，除了allocate memory外，new和delete還會呼叫structure或class的constructor來做初始化，所以會比malloc, free來得方便，不用自己做data type casting跟initialization