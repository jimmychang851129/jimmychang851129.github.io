---
layout: post
title:  "Program"
date:   2019-05-11 21:44:00
categories: Computer-Architecture
tags: Course
---

### 程式編譯過程

1. C program -> compiler -> assembly code(.o), object file
2. object file -> Linker
3. loader load到記憶體裡

![](assets/images/notes/CA/1-3.png)

1. 第一步可以透過`gcc -E`的指令把C preprocess然後產出text檔, 這一步基本上就是把macro替換掉, 加入一些function routine(exit,_start,_end)
2. 透過`gcc -S`可以把c檔變成assembly檔
3. `gcc -c` 則是可以把檔案編譯成object檔後不做linking stage直接停止, 這時就是binary形式, 要用objdump才能看到assembly, 但這單純就是把檔案編成binary, 他並不會啟動linker去連接需要的library


#### useful commands

- ldd: 看程式有link那些shared object
- nm: 看程式有哪些symbol
- objdump: 把binary變成asm, 但不會顯示shared object裡的library的asm, 只會顯示當前執行檔的
- readelf: 讀elf檔格式跟各個section位置

#### 執行流程

當編譯成執行檔並執行後, OS接收到指令會開啟一個Process來跑我們這個執行檔,同時OS也會allocate好記憶體跟page table給這個process, 而執行檔在編譯時就已經把一些C的startup routine連接好(libc_start_main等等) 所以program counter一開始會先把這些程式的start up routine跑完才開始跑main function, 接著either main function return或者呼叫exit 程式就會終止, 終止時會一樣由程式編譯進去的exit handler來處理好一些事情然後OS真的把process kill掉

![](assets/images/notes/CA/1-2.png)

#### Object module

編成assembly code時，有變成.o檔的形式，他會紀錄這個程式的header,text segment,relocation info(aslr關係，紀錄text,儲存位置的offset)，symbol table。<br />
library會用.o形式儲存，利用linker把library裡面的function link到那個主程式的檔案 

#### Linker

取得library,function)和把複數個object file合在一起(處理reloc,external reference(存取其他.o檔的變數、函式)

```
gcc file1.o file2.o -o exe : 把3個object檔statically link成一個executables
gcc -L[Dir] -l[object file] : -L就是加入library的位置, -l就是找Dir裡面的指定的library連起來(.so(dynamic link)或者.a(static link))
上面兩個步驟基本上就是static linking, 就是把所有object檔案擠在一起變成一個很肥的executables
```

#### Shared Object

![](/assets/images/notes/CA/1-5.png)


Object檔問題是每次編譯都要放到binary裡面, 一來是程式會變得很肥大, 二來是如果很多程式經常會使用某個object file, 那變成那個object file會複製很多份放到各個binary file裡面,  非常佔空間, 所以用shared object讓需要的人再來linked這個object, 而不用binary編譯時就把library放到程式裡面.

通常會下pic(position independent code)的指令, 目標就是把一個程式編譯成library的形式能夠給其他program之後import, 裡面可以含有多個.c .h檔, 把它包成一個so檔(如libc.so)

```
gcc -shared PIC test1.o test2.o -o libfoo.so
PIC指令讓code在編譯時盡量不要在asm裡面有絕對的記憶體位置, 盡量都用相對的形式(如rsp +0x10000之類的)
```

如果有用自己產生的shared object,執行時可能也要設定LD_LIBRARY_PATH, 不然linux會不知道去哪裡找shared object

#### Loading a program

loader在編譯時已經已shared object的形式跟binary檔link再一起(所以ldd binary file時除了看到libc library通常還會看到一個ld-linux.so, 這個就是loader), loader的工作就是把程式的symbol, 程式各個片段放到memory裡執行

把程式移到memory，
- 讀header(text segment, symbol table...)
- 建立virtual address
- 把程式、data寫進memory，stack建好(esp,ebp...)
- eip移到該處執行

### Dynamic linking (lazy linkage)

static linking直接把用到的library的.o檔放進binary file裡，結果是binary file會變超肥，因為包含很多.o檔。<br />
dynamic linking 只有在要call那個function時才load該.o檔<br />
第一次call function時，會用linker, loader把該.o檔、function import進來，第二次呼叫該function後就已經有該function，不用在call linker, loader，程式九已經把該function load進memory且知道位址了。

#### Reference

[shared library, object file](https://medium.com/@dkwok94/the-linking-process-exposed-static-vs-dynamic-libraries-977e92139b5f)<br />
[C compile stage](http://www-sop.inria.fr/dream/legacy/intro-devel-env.html)

### Program memory layout

![](/assets/images/notes/CA/1-1.jpg)

- stack allocate從high address到low address(往下長)
- heap allocate從low address到high address(往上長)
- bss:沒initialize的直會放在這裡，例如沒initialize的全域變數(但exec會幫忙做initialize to default value)
- data: 有initialize的data放這，例如initialize的全域變數
- bss/data section都是同時可以read/write
- text: 程式碼區段: 只能read,執行

stack 會有fp,sp紀錄現在這個frame

fp:存這個frame的base，
- 一來能夠在遞迴時fp持續指向上個stack frame位置，能夠在這個frame return後能再次回到上個frame位置，
- 本身不像sp會動，所以可以拿來當作指向這個stack裡面變數的基準

EX: `mov $eax, $fp + 0x48`

### ELF format

![](/assets/images/notes/CA/1-4.png)

- ELF header就是紀錄magic number, entry point, machine, type(.o, .so)之類的資訊
- Program header table紀錄各個section位置
